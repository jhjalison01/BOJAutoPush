#정삼각형을 타일로 덮는 방법
#1. 위쪽 정삼각형과 함께 마름모 타일로 덮기
#2. 왼쪽 정삼각형과 함께 마름모 타일로 덮기
#3. 오른쪽 정삼각형과 함께 마름모 타일로 덮기
#4. 정삼각형 타일로 덮기
def solution(n, tops):
    MOD = 10007
    #a[k]: k번째 아래 방향 정삼각형까지 덮되, k번째 아래 방향 정삼각형을 덮는 방법이 3번 방법인 경우의 수
    a = [0] * (n + 1) 
    #b[k]: k번째 아래 방향 정삼각형까지 덮되, k번째 아래 방향 정삼각형을 덮는 방법이 3번 방법이 아닌 경우의 수
    b = [0] * (n + 1)
    a[0] = 0
    b[0] = 1
    for k in range(1, n + 1):
        #k-1번째 아래 방향 삼각형 위에 top이 있는 경우
        if tops[k - 1]:
            #전 정삼각형을 어떻게 덮었는지에 상관 없이 k번째 정삼각형을 3번 방법대로 덮을 수 있음
            a[k] = (a[k - 1] + b[k - 1]) % MOD
            #전 정삼각형을 3번 방법으로 덮었을 경우 - 1번, 4번 방법대로 덮을 수 있음
            #전 정삼각형을 3번 방법 외로 덮었을 경우 - 1번, 2번, 4번 방법대로 덮을 수 있음
            b[k] = (2 * a[k - 1] + 3 * b[k - 1]) % MOD
        #k-1번째 아래 방향 삼각형 위에 top이 없는 경우
        else:
            #전 정삼각형을 어떻게 덮었는지에 상관 없이 k번째 정삼각형을 3번 방법대로 덮을 수 있음
            a[k] = (a[k - 1] + b[k - 1]) % MOD
            #전 정삼각형을 3번 방법으로 덮었을 경우 - 4번 방법대로 덮을 수 있음
            #전 정삼각형을 3번 방법 외로 덮었을 경우 - 2번, 4번 방법대로 덮을 수 있음
            b[k] = (a[k - 1] + 2 * b[k - 1]) % MOD
    return (a[n] + b[n]) % MOD
    